如何写一个简单的编译器？ - 杞鋂的回答 - 知乎
https://www.zhihu.com/question/36756224/answer/2516138990
目录
一.Brainfuck是什么？

1.用“走路”来理解BF语言？

2.BF代码？

a.100步

b.50步

c.4步

3.类BF编译器

a.类BF和Brainfuck代码

二.类BF编译器

1.实现语言

a.C语言

b.C语言printf

2.C语言编译BF10编译器

a.用C识別BF代码

（1）使用char定义变量

b.用C把BF代码转换计数

(1)switch

c.打印步数

(1)printf

d.识別2个字符的类BF编译器

(1)只能识別一个字符

(2)使用while

(3)代码剖析

e.识別3字符

f.识別5字符

g.识別7字

（1）[就是向前：

（2）]就要跳到[：

(2.1) ".]"重复

(2.2)">+++.]"重复

(2.3) "[]"重复

(2.4)用while表示”c-=自然数“

三.由类BF到BF编译器

1.把10进制变成ASCII：只要把%d换成%c

2.最后一个符号,

四.附录

1.ASCII码表

2.MAC安装Gcc

一.Brainfuck是什么？
想写一个最简单的编译器，就得找最小化的语言，说明白些，就是要找一个最小功能的编程语言，无疑就是Brainfuck。

Brainfuck，是一种极小化的程序语言，它是由Urban Müller在1993年创造的。
由于fuck在英语中是脏话，这种语言有时被称为Brainf*ck或Brainf***，或被简称为BF。
官方说明：

Müller的目标是建立一种简单的、可以用最小的编译器来实现的、符合图灵完全思想的编程语言。这种语言由八种运算符构成，为Amiga机器编写的编译器（第二版）只有240个字节大小。

下面是这八种状态的描述，其中每个状态由一个字符标识：

字符	含义
>	指针加一
<	指针减一
+	指针指向的字节的值加一
-	指针指向的字节的值减一
.	输出指针指向的单元内容（ASCII码）
,	输入内容到指针指向的单元（ASCII码）
[	如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处
]	如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处
总之，看着似懂非懂，算了，笔者反正看这一堆官方的东西，完全不懂，于是，启动了最强大的学习方法——幻想，幻想自己能懂。

1.用“走路”来理解BF语言？


从A点开始走，走到B点时，要跳回A点继续走，不断地循环
字符	含义
>	向右移动一步
<	向左移动一步
+	往前走一步
-	往后走一步
.	播报ASCII码，如走了72步就报播字母H
,	喊字母H，就要走相应的步数
[	重复走的始点
]	重复走的终点
这样基本就好懂得多，例如：

2.BF代码？
a.100步
BF代码：“100+”和“1.”

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
可以把以上代码复制粘贴到以下在线BF编译器，点击"Brainfuck to Text"查看编译结果。

deobfuscator. Decode and encode online.
​tool.bugku.com/brainfuck/
这是往前有了100步，然后报播第100位的ASCII码对应的d。


完整ASCII码在附录1，可以自己查询。

如果BF代码：“100+”，“1-”，“1+”，“1.”

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-+.
也就是走了80步又退一步79再进一步，还是100步，就还是播报d。



b.50步

BF代码："50+"，"1."，"1>"，“50+”，“1.”

++++++++++++++++++++++++++++++++++++++++++++++++++.
>++++++++++++++++++++++++++++++++++++++++++++++++++.
这串BF代码的意思，就是往前走50步后，播报d;然后向右走一步，再往前走50步，又报播了2。

也就是原地报播了d,然后往右走了一步后，再往前走50步，又报播2。


c.4步

BF代码："2+"，"1."，"1>"，“2+”，“1.”

++.[>++<-]>.
这串BF代码的意思:

++.[>++<-]>.=++.>++<->++<->.
就是往前走2步后，播报STX(++.) 。

向右走一步，再往前走2步（2步）(>++)。

往左跳到第2步的位置，退后一步（1步），进入循环(<-)；

往右跳到方才第2步，再往前走2步（4步）(>++)。

往左跳到方才第1步的位置，退后一步（0步）(<-)；终止循环(因为第一位的步数为0)；

往右跳到方才第4步，播报EOF(>.)。

以下是在线图示BF编译器（有时连不上）：

https://brainfuck-visualizer.herokuapp.com/
​brainfuck-visualizer.herokuapp.com/

图示化运行Brainfuck code
                               +-------------------------+
                          (13) |                         |  
                +------------->1(1)-----------------+    | 
                |          (8) |                    |    |    
                |    +-------->2(2)[STX](3)         |    | 
                |    |         +-(4)-+             (9)  (14) 
                |    |               |              |    | 
              (12)  (7)              1(5)           |    | 
                |    |               |              |    | 
                |    +---------------2(6)<----------+    | 
                |                    |                   | 
                |                    3(10)               | 
                |                    |                   | 
                +--------------------4(11)<--------------+ 
                                     +[EOF](15)
已经理解了这些BF代码，就大概知道写个BF编译器是做什么的？

        +------------+             +------------+             +------------+
        |   +-<>[].  |    ----->   |   switch   |   ----->    | ASCII code |
        +------------+             +------------+             +------------+
            BF代码                    编译器(转换)                  ASCII码
3.类BF编译器
a.类BF和Brainfuck代码

鉴于一般的编辑器，不能显示0-31的ASCII码，于是笔者就让其 “.”不是播报ASCII码，而播报步数，也就是播报数值。

        +------------+             +------------+             +------------+
        |   +-<>[].  |    ----->   |   switch   |   ----->    |     0~∞    |
        +------------+             +------------+             +------------+
            BF代码                    编译器(转换)                  10进制
看回之前的示例BF代码：

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-+.
//100
++++++++++++++++++++++++++++++++++++++++++++++++++.
>++++++++++++++++++++++++++++++++++++++++++++++++++.
//50
//50


++.[>++<-]>.
//2
//4
二.类BF编译器
1.实现语言
a.C语言
C是一种通用的、过程式编程编程语言，支持结构化编程、词法作用域和递归，使用静态类型系统，并且广泛用于系统软件与应用软件的开发。

C语言具有高效、灵活、功能丰富、表达力强和较高的可移植性等特点，在程序设计中备受青睐，成为最近25年使用最为广泛的编程语言。

用来写编译器最好不过了。

b.C语言printf
https://www.onlinegdb.com/online_c_compiler
​www.onlinegdb.com/online_c_compiler
用以上链接打开在线C语言编译器，直接点RUN，就能运行第一个C语言程序

C语言的Hello World！

#include <stdio.h>
int main(){
printf("Hello word!\n");
return 0;}
//\n是换行符
运行后：

Hello World


2.C语言编译类BF编译器
a.用C识別BF代码
（1）使用char定义变量
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
b.用C把BF代码转换计数
(1)switch
switch又是 什么？

同样，要跑代码就知道了，空嘴讲真的比跑代码更简单。

把以下代码复制到在线C语言编译器运行，

#include <stdio.h>
int main(){
    int a;
    printf("Input integer number:");
    scanf("%d",&a);
    switch(a){
        case 1: printf("Monday\n");break;
        case 2: printf("Tuesday\n");break;
        case 3: printf("Wednesday\n");break;
        case 4: printf("Thursday\n");break;
        case 5: printf("Friday\n");break;
        case 6: printf("Saturday\n");break;
        case 7: printf("Sunday\n");break;
        default:printf("error\n");break;
    }
    return 0;
}
这个要实现的功能就是直接输入case后面的数字，就会打印星期几。

Input integer number:1
Monday
$
Input integer number:2
Tuesday
$
Input integer number:3
Wednesday
因此到这里，输入1得出Monday，输入2得出Tuesday，以此类推。

于是可以理解为输入+得出地址+1，地址就向前走一步。

switch(a){
        case +: (*dp)++;break;
但是每读取一个，只能运行一次。

于是就知道大概的写法：

switch(BF代码++){
        case '+': 地址++;break;
    }
c.打印步数
(1)printf
        case '.': printf("10进制",地址++);break;
所以最后代码就是：

char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码
switch(BF代码++){
        case '+': 地址++;break;
        case '.': printf("10进制",地址);break;
    }
//转换BF代码
d.识別2个字符的类BF编译器
(1)只能识別一个字符
把代码补完为C语言的代码：

#include <stdio.h>
char f[10000],*dp=f;
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码
int main() {
switch(*c++){
        case '+': (*dp)++;break;
        case '.': printf("%d",(*dp));break;
    }
//转换BF代码
printf("%p\n",(*dp));//打印查看原始的地址和运行后的地址，看这段代码是否有运行
}
运行后：

0x1
//只执行了一次，占了一个地址
用switch......case运行一次，只能转换一个字符，所以回想之前的例子，每次运行只能输入一次数字，显示一次星期数，下次又要运行才能再输入，所以要加入循环。

现在要解决的问题是：

每次运行只读取*c中的第一个字符+，要让*c的字符一个一个重复传到switch......case。

脑子里有重复的功能的关键字乃for/while。

(2)使用while
直接跑一段代码：

#include <stdio.h>
int main(){
int a =10;
while (a<20){
  printf("a is %d\n",a);
  a++;
}
return 0;
}
直接运行

a is 10
a is 11
a is 12
a is 13
a is 14
a is 15
a is 16
a is 17
a is 18
a is 19
这个就是打印a到屏幕，起始值为10，什么时候停止？当a=19时就停止。

不懂的话，可以把10换成別的数值，把20换成別的数值，好好体验一下while，如果写成这样：

#include <stdio.h>
int main(){
int a =10;
while (1){
  printf("a is %d\n",a);
  a++;
}
return 0;
}
如果电脑运行想停止只能按ctrl+c，如果是在线编译器就会运行到error。

#include <stdio.h>
char f[10000],*dp=f;
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码
int main() {
while(*c)
printf("%p\n",(*c));
}
运行后（就是不断打印BF代码）：

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
再运行一段代码（把c改为c++）：

#include <stdio.h>
char f[10000],*dp=f;
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码
int main() {
//while(*c)
while(*c++)
printf("%p\n",(*c));
}
运行后：

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++.
++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++.
++++++++++++++++++++++++++.
+++++++++++++++++++++++++.
++++++++++++++++++++++++.
+++++++++++++++++++++++.
++++++++++++++++++++++.
+++++++++++++++++++++.
++++++++++++++++++++.
+++++++++++++++++++.
++++++++++++++++++.
+++++++++++++++++.
++++++++++++++++.
+++++++++++++++.
++++++++++++++.
+++++++++++++.
++++++++++++.
+++++++++++.
++++++++++.
+++++++++.
++++++++.
+++++++.
++++++.
+++++.
++++.
+++.
++.
+.
.
看着好似明白了一些东西，但说不出来是什么？

总之，现在就已经把循环解决了？

真的吗？

#include <stdio.h>
char f[10000],*dp=f;
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码

int main() {

while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '.': printf("%d\n",(*dp));break;
   
    }};
//转换BF代码
     printf("%p\n",(*dp));//打印查看原始的地址和运行后的地址，看这段代码是否有运行

}
运行后：

100
0x64
//100的16进制就是64
(3)代码剖析
#include <stdio.h>
//引用函数库
char f[10000],*dp=f;
//设定变量
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码

int main() {

while(*c){
//不断输入*c的101个字符
switch(*c++){
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
//.......此处为省略
//+++.
//++.
//+.
//.
        case '+': (*dp)++;break;
//101个字符识別第一个+为0x1
//100个字符识別第一个+为0x2
//99个字符识別第一个+为0x3
//.......此处为省略
//+++.识別第一个+为0x62
//++.识別第一个+为0x63
//+.识別第一个+为0x64
        case '.': printf("%d\n",(*dp));break;
//.识別并打印为10进制100
   
    }};
//转换BF代码
     printf("%p\n",(*dp));//打印运行后的地址0x64

}
e.识別3字符
把输入的BF 代码换为

++++++++++++++++++++++++++++++++++++++++++++++++++.
>++++++++++++++++++++++++++++++++++++++++++++++++++.

同时要加入“>”的转换代码：case '>': dp++;break;
则：

#include <stdio.h>
char f[10000],*dp=f;
char *c="++++++++++++++++++++++++++++++++++++++++++++++++++.>++++++++++++++++++++++++++++++++++++++++++++++++++.";
//输入BF代码

int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '.': printf("%d\n",(*dp));
   
    }};
//转换BF代码
     printf("%p\n",(*dp));//打印查看原始的地址和运行后的地址，看这段代码是否有运行

}
运行后：

50
50
0x32//50的16进制
f.识別5字符
把输入的BF 代码换为

+++.>><++-.
用走路的例子，来理解就是：

|
1
|
2
|
3(播报3)
.-1-2（往右走两步，又往左一步）
  |
  1.(播报1)（往前走两步又退后一步）
  |
  2
最后的结果就是:
3
1
同时要加入“<-”的转换代码：

case '<': dp--;break; 
case '-': (*dp)--;break;
则：

#include <stdio.h>
char f[10000],*dp=f;
char *c="+++.>><++-.";
//输入BF代码

int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));
   
    }};
//转换BF代码
     printf("%p\n",(*dp));//打印查看原始的地址和运行后的地址，看这段代码是否有运行
}
运行后：

3
1
0x1//1的16进制
g.识別7字
最后要到最难的两个字符[]，这两个字符比较难理解，只要跟着笔者一步一步来，基本上都是小K事。


把输入的BF 代码换为

++.[>++<-]>.
代码可等价于
++.[>++<-]>.=++.>++<->++<->.
效果如下：

                               +-------------------------+
                          (13) |                         |  
                +------------->1(1)-----------------+    | 
                |          (8) |                    |    |    
                |    +-------->2.(2)[STX](3)        |    | 
                |    |         +-(4)-+             (9)  (14) 
                |    |               |              |    | 
              (12)  (7)              1(5)           |    | 
                |    |               |              |    | 
                |    +---------------2(6)<----------+    | 
                |                    |                   | 
                |                    3(10)               | 
                |                    |                   | 
                +--------------------4(11)<--------------+ 
                                     +.[EOF](15)
[]的转换代码应该如何写？

case '[': ？;break; 
case ']': ？;break;
"+-<>"都是简单地++--就可以了，那样“[]”要如何去写？

对于初学者而言，唯一的办法就是从“事实”为主，想要怎样的效果，就怎么去编写程序！


（1）[就是向前：
++.[>++<-]>.
回想走路的例子，当看到”++“时就往前走两步，看到”.“就播报当前的步数：2步。

当看到"["时，什么都不用管，只要继续下一个就可以了，不同于”]“，要跳起来。

所以可以确定：”[“只是一个跳转的标志，所以说完全可以不用管。

（2）]就要跳到[：
A B C D E F G H I J K L
+ + . [ > + + < - ] > .
当到了J时就要跳到D,如何会停止循环？

按走路的例子，就是只要回到原地就会停止循环，用符号来表示，就是当++遇到--时就会停止循环。

顺序就是：A-C，D-J，KL。

A-C和KL都不用管，现在是怎样让D-J不断地来回走呢？

要完成D-J来回走，不如先实现JI重复？

为了测试效果笔者换另一串代码：

++.[>+.]>.
(2.1) ".]"重复
++.[>+.]>.
=++.(>+.)(.)(.)(.)(.).......
//效果：
//++.先报播2，然后到>+.再报播1，最后无限重复地报播11111111
//>.最后的两个”>.“肯定就没影了
代码如下：

#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>+.]>.";
//输入BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c-=2;};break;
/*
A: 0123456789
   ++.[>+.]>.
B:    54321
设b=1,就是从]开始数；
c-=2,就是指B列由第1位退到第2位，就是由]到.
*/
   
    }};
//转换BF代码
}
运行后：

2
1
1
1
......
1
1
1
和预想的一致，也就是代码已经实现了".]"重复。

(2.2)">+++.]"重复
为了区別，即把代码改为

++.[>+++.]>.
=++.(>+++.)(>+++.)(>+++.)(>+++.)(>+++.).......
//效果：
//++.先报播2，然后到>+++.再报播3，最后无限重复地报播33333
//>.最后的两个”>.“肯定就没影了
用走路的例子就是：

|
1
|(报2)
2.——1+
     |
     1
     |
     2
     |(报3)
     3.——1+
         |
         1
         |
         2
         |(报3)
         3.——1+
...............如此类推
代码如下：

#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>+++.]>.";
//输入BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c-=6;};break;
/*
A: 0123456789
   ++.[>+++.]>.
B:    7654321
设b=1,就是从]开始数；
c-=6,就是指B列由第1位退到第6位，就是由]到>
*/
   
    }};
//转换BF代码
}
运行后：

2
3
3
3
......
3
3
3
很显然又成功了，也就是代码已经实现了">+++.]"重复，那样就要攻克最后一关了。

(2.3) "[]"重复
基本上经过以上两个例子，可以得知“[]”重复循环的实现方法。

A: 0123456789
   ++.[>+++.]>.
B:    7654321
假设"[]"中有6个字符，那样就设c-=6或c-=7（因为"["不用识別转换）。

假设"[]"中有100个字符，那样就设c-=100或c-=101（因为"["不用识別转换）。

但总不能每次都在改c-=101的数字，所以设定"[]"中的字符为b，那样是否就可以定为c-=b?

完整代码：

#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>+++.]>.";
//输入BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c-=b;};break;//直接用c-=b?
/*
A: 0123456789
   ++.[>+++.]>.
B:    7654321
设b=1,就是从]开始数；
c-=6,就是指B列由第1位退到第6位，就是由]到>
*/
   
    }};
//转换BF代码
}
很显然这样是无法运行，理论上是这样，但是这样的代码是无法运行！

c-=1;
c-=2;
c-=3;
c-=4;
c-=5;
c-=6;
c-=7;
c-=8;
.......
//以上都可以运行
c-=b；//就不能运行，为什么？可以思考下
(2.4)用while表示“c-=自然数”
既然c-=b不能运行，那样可以换另一种方式。

A: 0123456789
   ++.[>+?.]>.
B:    6543N1
b=1,就是];
直接指定*c=='?'的位置，就是N。
如果想让”.]“重复，则用

if(*c=='?')b--
但BF代码则是：

++.[>+?.]>.
   654321
完整代码：

#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>+?.]>.";
//输入BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c--;while(b){c--;if(*c=='?')b--;}};break;
/*
A: 0123456789
   ++.[>+?.]>.
B:    654321
设b=1,就是从]开始数；
c--,BF码退一位；
*c=='?'就是当退到?时，就执行b--（再退一位）,就退到+,所以是由]到+，不断地重复
*/
   
    }};
//转换BF代码
}
如果想让“>+++.]”重复，则用

if(*c=='?')b--
但BF代码则是：

++.[?>+++.]>.
   87654321
如果想让”+.]“重复，则用
if(*c=='?')b--
完整代码：

#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[?>+++.]>.";
//输入BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c--;while(b){c--;if(*c=='?')b--;}};break;
/*
A: 0123456789
   ++.[?>+++.]>.
B:    87654321
设b=1,就是从]开始数；
c--,BF码退一位；
*c=='?'就是当退到?时，就执行b--（再退一位）,就退到[,所以是由]到[，不断地重复
*/
   
    }};
//转换BF代码
}
又剖析代码：

if(*dp){//当*dp为真时执行，就是代码有效时就会有效
b=1;c--;//设b=1的位置就是],c--就是由”]“位倒数过去
while(b){//重复由b=1到终止位的字符
c--;//倒数
if(*c=='?')b--;
//当运行到”？“时，就退后一位，则就由？开始循环，一直到],再到？时，就退到前一位，又由？开始，周而复始
}};
所以说，想用“[]”重复,则用

if(*c=='?')b--
但BF代码则是：

++.?[>+++.]>.
   87654321
如果想让”+.]“重复，则用
if(*c=='?')b--
既然都用"?"作标记符，何不直接用”[“作标记符？ 故为：

if(*c=='[')b--
最终代码为：

 #include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>++<-]>.";
//输入最开始七个字符的BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%d\n",(*dp));break;
        case ']': if(*dp){b=1;c--;while(b){c--;if(*c=='[')b--;}};break;
/*
A: 0123456789
   ++.[>++<.]>.
B:    7654321
设b=1,就是从]开始数；
c--,BF码退一位；
*c=='?'就是当退到?时，就执行b--（再退一位）,就退到[,所以是由]到[，不断地重复
[]不断循环
*/
   
    }};
//转换BF代码
}
//运行后结果
//2
//4
三.由类BF到BF编译器
1.把10进制变成ASCII：只要把%d换成%c
#include <stdio.h>
int b;
char f[10000],*dp=f;
char *c="++.[>++<-]>.";
//输入最开始七个字符的BF代码
int main() {
while(*c){
switch(*c++){
        case '+': (*dp)++;break;
        case '>': dp++;break;
        case '<': dp--;break;
        case '-': (*dp)--;break;
        case '.': printf("%c\n",(*dp));break;
        case ']': if(*dp){b=1;c--;while(b){c--;if(*c=='[')b--;}};break;
/*
A: 0123456789
   ++.[>+++.]>.
B:    7654321
[]不断循环
*/
   
    }};
//转换BF代码
}
//运行后结果
//STX
//EOF
BrainFuck的Hello World！代码：

++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
试试刚新鲜出炉的BF编译器：

#include <stdio.h>
int b;char f[20000],*dp=f;
char *c="++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.";
int main(){
while(*c)
switch(*c++){
 case '+':(*dp)++;break;
 case '-':(*dp)--;break;
 case '>':dp++;break;
 case '<':dp--;break;
 case '.':printf("%c",(*dp));break;
 case ']':if((*dp)){b=1;c--;while(b){c--;if(*c=='[')b--;}};break;
}
}
2.最后一个符号,
基本上明白了7个字符都差不多明白了，而最后一个转换符也就更容易明白了。

，:把ASCII码转换成地址
“,” 就是把地址（指针）转换成ASCII码，","就是反过来。

将字符串,+.放入“代码”框，将字母“a”放入“输入”框或使用以下链接

Skilldrick's JavaScript brainfuck interpreter
​skilldrick.co.uk/brainfuck/?code=,+.&input=a
然后按“run”，尝试使用不同的输入，就明白了。


已经介绍完毕，笔者只是尽可能地简单讲解BrainFuck编译器，并且水平有限，在讲解上，并没有讲得太明白，如解释器和编译器方面，也未能展开，而且这个编译器并非最好的，但笔者感觉应该算是最好理解最简单的Brainfuck编译器。

国內外的大牛更牛，有更好的brainfuck编译器，不光是JS版Brainfuck编译器、C++版Brainfuck编译器、JAVA版Brainfuck编译器，还有Brainfuck版的编译器。

另外，如笔者有时间，闲了再继续写写C语言编译器。

四.附录
1.ASCII码表
Bin(二进制)	Oct(八进制)	Dec(十进制)	Hex(十六进制)	缩写/字符	解释
0000 0000	00	0	0x00	NUL(null)	空字符
0000 0001	01	1	0x01	SOH(start of headline)	标题开始
0000 0010	02	2	0x02	STX (start of text)	正文开始
0000 0011	03	3	0x03	ETX (end of text)	正文结束
0000 0100	04	4	0x04	EOT (end of transmission)	传输结束
0000 0101	05	5	0x05	ENQ (enquiry)	请求
0000 0110	06	6	0x06	ACK (acknowledge)	收到通知
0000 0111	07	7	0x07	BEL (bell)	响铃
0000 1000	010	8	0x08	BS (backspace)	退格
0000 1001	011	9	0x09	HT (horizontal tab)	水平制表符
0000 1010	012	10	0x0A	LF (NL line feed, new line)	换行键
0000 1011	013	11	0x0B	VT (vertical tab)	垂直制表符
0000 1100	014	12	0x0C	FF (NP form feed, new page)	换页键
0000 1101	015	13	0x0D	CR (carriage return)	回车键
0000 1110	016	14	0x0E	SO (shift out)	不用切换
0000 1111	017	15	0x0F	SI (shift 戈in)	启用切换
0001 0000	020	16	0x10	DLE (data link escape)	数据链路转义
0001 0001	021	17	0x11	DC1 (device control 1)	设备控制1
0001 0010	022	18	0x12	DC2 (device control 2)	设备控制2
0001 0011	023	19	0x13	DC3 (device control 3)	设备控制3
0001 0100	024	20	0x14	DC4 (device control 4)	设备控制4
0001 0101	025	21	0x15	NAK (negative acknowledge)	拒绝接收
0001 0110	026	22	0x16	SYN (synchronous idle)	同步空闲
0001 0111	027	23	0x17	ETB (end of trans. block)	结束传输块
0001 1000	030	24	0x18	CAN (cancel)	取消
0001 1001	031	25	0x19	EM (end of medium)	媒介结束
0001 1010	032	26	0x1A	SUB (substitute)	代替
0001 1011	033	27	0x1B	ESC (escape)	换码(溢出)
0001 1100	034	28	0x1C	FS (file separator)	文件分隔符
0001 1101	035	29	0x1D	GS (group separator)	分组符
0001 1110	036	30	0x1E	RS (record separator)	记录分隔符
0001 1111	037	31	0x1F	US (unit separator)	单元分隔符
0010 0000	040	32	0x20	(space)	空格
0010 0001	041	33	0x21	!	叹号
0010 0010	042	34	0x22	"	双引号
0010 0011	043	35	0x23	#	井号
0010 0100	044	36	0x24	$	美元符
0010 0101	045	37	0x25	%	百分号
0010 0110	046	38	0x26	&	和号
0010 0111	047	39	0x27	'	闭单引号
0010 1000	050	40	0x28	(	开括号
0010 1001	051	41	0x29	)	闭括号
0010 1010	052	42	0x2A	*	星号
0010 1011	053	43	0x2B	+	加号
0010 1100	054	44	0x2C	,	逗号
0010 1101	055	45	0x2D	-	减号/破折号
0010 1110	056	46	0x2E	.	句号
0010 1111	057	47	0x2F	/	斜杠
0011 0000	060	48	0x30	0	字符0
0011 0001	061	49	0x31	1	字符1
0011 0010	062	50	0x32	2	字符2
0011 0011	063	51	0x33	3	字符3
0011 0100	064	52	0x34	4	字符4
0011 0101	065	53	0x35	5	字符5
0011 0110	066	54	0x36	6	字符6
0011 0111	067	55	0x37	7	字符7
0011 1000	070	56	0x38	8	字符8
0011 1001	071	57	0x39	9	字符9
0011 1010	072	58	0x3A	:	冒号
0011 1011	073	59	0x3B	;	分号
0011 1100	074	60	0x3C	<	小于
0011 1101	075	61	0x3D	=	等号
0011 1110	076	62	0x3E	>	大于
0011 1111	077	63	0x3F	?	问号
0100 0000	0100	64	0x40	@	电子邮件符号
0100 0001	0101	65	0x41	A	大写字母A
0100 0010	0102	66	0x42	B	大写字母B
0100 0011	0103	67	0x43	C	大写字母C
0100 0100	0104	68	0x44	D	大写字母D
0100 0101	0105	69	0x45	E	大写字母E
0100 0110	0106	70	0x46	F	大写字母F
0100 0111	0107	71	0x47	G	大写字母G
0100 1000	0110	72	0x48	H	大写字母H
0100 1001	0111	73	0x49	I	大写字母I
01001010	0112	74	0x4A	J	大写字母J
0100 1011	0113	75	0x4B	K	大写字母K
0100 1100	0114	76	0x4C	L	大写字母L
0100 1101	0115	77	0x4D	M	大写字母M
0100 1110	0116	78	0x4E	N	大写字母N
0100 1111	0117	79	0x4F	O	大写字母O
0101 0000	0120	80	0x50	P	大写字母P
0101 0001	0121	81	0x51	Q	大写字母Q
0101 0010	0122	82	0x52	R	大写字母R
0101 0011	0123	83	0x53	S	大写字母S
0101 0100	0124	84	0x54	T	大写字母T
0101 0101	0125	85	0x55	U	大写字母U
0101 0110	0126	86	0x56	V	大写字母V
0101 0111	0127	87	0x57	W	大写字母W
0101 1000	0130	88	0x58	X	大写字母X
0101 1001	0131	89	0x59	Y	大写字母Y
0101 1010	0132	90	0x5A	Z	大写字母Z
0101 1011	0133	91	0x5B	[	开方括号
0101 1100	0134	92	0x5C	\	反斜杠
0101 1101	0135	93	0x5D	]	闭方括号
0101 1110	0136	94	0x5E	^	脱字符
0101 1111	0137	95	0x5F	_	下划线
0110 0000	0140	96	0x60	`	开单引号
0110 0001	0141	97	0x61	a	小写字母a
0110 0010	0142	98	0x62	b	小写字母b
0110 0011	0143	99	0x63	c	小写字母c
0110 0100	0144	100	0x64	d	小写字母d
0110 0101	0145	101	0x65	e	小写字母e
0110 0110	0146	102	0x66	f	小写字母f
0110 0111	0147	103	0x67	g	小写字母g
0110 1000	0150	104	0x68	h	小写字母h
0110 1001	0151	105	0x69	i	小写字母i
0110 1010	0152	106	0x6A	j	小写字母j
0110 1011	0153	107	0x6B	k	小写字母k
0110 1100	0154	108	0x6C	l	小写字母l
0110 1101	0155	109	0x6D	m	小写字母m
0110 1110	0156	110	0x6E	n	小写字以u（山）母n
0110 1111	0157	111	0x6F	o	小写字母o
0111 0000	0160	112	0x70	p	小写字母p
0111 0001	0161	113	0x71	q	小写字母q
0111 0010	0162	114	0x72	r	小写字母r
0111 0011	0163	115	0x73	s	小写字母s
0111 0100	0164	116	0x74	t	小写字母t
0111 0101	0165	117	0x75	u	小写字母u
0111 0110	0166	118	0x76	v	小写字母v
0111 0111	0167	119	0x77	w	小写字母w
0111 1000	0170	120	0x78	x	小写字母x
0111 1001	0171	121	0x79	y	小写字母y
0111 1010	0172	122	0x7A	z	小写字母z
0111 1011	0173	123	0x7B	{	开花括号
0111 1100	0174	124	0x7C	|	垂线
0111 110个1	0175	125	0x7D	}	闭花括号
0111 1110	0176	126	0x7E	~	波浪号
0111 1111	0177	127	0x7F	DEL (delete)	删除
2.MAC安装Gcc
MAC折腾怎么安装gcc，用的是：

brew install gcc
输入了才发现，没有安装brew，于是又去学习了怎么安装brew，brew还要用中国的源，不然就会很慢，就找了一会教程，就找到了这个国人搞的中国brew。

$/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"
果然很快就安装好了，接下来，最后有个跳转点赞的页面，算了，也就点个赞而已，总不能白嫖嘛，给开发者点了个赞。

接下来，继续安装gcc

$brew install gcc
安装完毕后

$gcc -v
Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/4.2.1
Apple clang version 13.0.0 (clang-1300.0.29.3)
Target: x86_64-apple-darwin21.4.0
Thread model: posix
这样就很不对了，怎么是clang呢？找了一通，原来MAC里用的是clang来替代gcc，那样为之奈何？

于是突发奇想，不如试试这样？

$ gcc-11 -v
Using built-in specs.
COLLECT_GCC=gcc-11
COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc/11.2.0_3/bin/../libexec/gcc/x86_64-apple-darwin20/11/lto-wrapper
Target: x86_64-apple-darwin20
Configured with: ../configure --prefix=/usr/local/opt/gcc --libdir=/usr/local/opt/gcc/lib/gcc/11 --disable-nls --enable-checking=release --with-gcc-major-version-only --enable-languages=c,c++,objc,obj-c++,fortran,d --program-suffix=-11 --with-gmp=/usr/local/opt/gmp --with-mpfr=/usr/local/opt/mpfr --with-mpc=/usr/local/opt/libmpc --with-isl=/usr/local/opt/isl --with-zstd=/usr/local/opt/zstd --with-pkgversion='Homebrew GCC 11.2.0_3' --with-bugurl=https://github.com/Homebrew/homebrew-core/issues --enable-libphobos --build=x86_64-apple-darwin20 --with-system-zlib --disable-multilib --with-native-system-header-dir=/usr/include --with-sysroot=/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 11.2.0 (Homebrew GCC 11.2.0_3) 
果然加上了版本号，就成功了，那样打命令时，就得加上gcc-11？

第一个C语言的程序是屏幕打印Hello world

#include <stdio.h>

int main(){

printf("Hello World!\n")

return 0;
}
然后报错了，原因是“printf("Hello World!\n")”没有加";"。

#include <stdio.h>

int main(){

printf("Hello World!\n");

return 0;
}
后面在电脑上运行：

$gcc-11 -o hello hello.c
$./hello
Hello World!
原本的gcc -o hello hello.c，就会用clang来编译，现在用gcc-11就用gcc来编译了。

本文版权所有，已托平台维护，禁止转载，如需授权，请私信笔者。

特此声明，盗文者莫以为删文可止，笔者必追究到底。
